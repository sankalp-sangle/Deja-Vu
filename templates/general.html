{% extends 'base.html' %}

{% block title %}
General
{% endblock title %}

{% block navigationTabs %}
    <li><a href={{ url_for('flows') }}>Go back</a></li>
{% endblock navigationTabs %}

{% block page_content %}

<div class="row">
  <div class="col-sm-6">
    <button id="play" onclick="start()">Play</button>
    <button id="pause" onclick="myFunction()" disabled>Pause</button>
    <button id="resume" onclick="resume()" disabled>Resume</button>
  </div>

  <div class = "col-sm-6">
    <button onclick="updateMaxD()">Update Maximum Depth</button>
    <textarea id="maxD" rows="1" cols="10">
      {{maxD.val}}</textarea>
  </div>
</div>

<div class="row">
    <!-- <div class="d-flex justify-content-center my-4"> -->
        <!-- <form class="range-field w-75"> -->
          <input id="slider11" class="border border-primary" type="range" min="{{minLim}}" max="{{maxLim}}" >
        <!-- </form> -->
        <span class="font-weight-bold text-primary ml-2 mt-1 valueSpan">Press Play to begin...</span>
    <!-- </div> -->
</div>

<style>
    .box{
        width:25px;
        height:25px;
    }
    .blue{
        background:blue
    }

    .red{
        background:#f00;
    }
    .yellow{
        background:rgb(251, 255, 10);
    }
    .gray{
        background:rgb(144, 144, 168);
    }
    .black{
        background:#000;
    }
    </style>


<div class="col-sm-12">
<svg width="960" height="400">
  <text x="300" y="15" fill="orange" font-weight="bold">Switch</text>
</svg>
</div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script>

$(document).ready(function() {

const $valueSpan = $('.valueSpan');
const $value = $('#slider11');


$value.on('input change', () => {

  var x = $value.val()  
  $valueSpan.html("Time: " + $value.val() + " nanos");
  d3.selectAll("circle")
    .attr("r", function(node) { return getRadius(node) })
  d3.selectAll("line")
    .attr("stroke-width", getThickness)
    .attr("stroke", getStrokeColour)
  base = Number(x)
});
});

var levels = {{levels|tojson|safe}}
var nodes = {{nodelist|tojson|safe}}

var links = {{linklist|tojson|safe}}

var datass = {{datas|tojson|safe}}

var throughputs = {{throughput|tojson|safe}}

var throughputlimitss = {{throughputlimits|tojson|safe}}

var limitss = {{limits|tojson|safe}}

var minTime = {{minLim2|tojson|safe}}

var maxTime = {{maxLim2|tojson|safe}}

var maxRad = 60
var minRad = 20

var maxD = {{maxD|tojson|safe}}

// Define the div for the tooltip
var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);

var interval = maxTime.val - minTime.val
var factor = interval / 20000
var timer

var base = minTime.val

const $play=$('#play')
const $pause=$('#pause')
const $resume=$('#resume')

function start () {
      timer = d3.timer(function(duration) {
      // console.log(minTime)
      document.getElementById("slider11").value = duration * factor + base
      const $valueSpan = $('.valueSpan');
      const $value = $('#slider11');
      $valueSpan.html("Time: " + $value.val() + " nanos");
      // console.log(duration);
      d3.selectAll("circle")
      .attr("r", function(node) { return getRadius(node) })
      d3.selectAll("line")
      .attr("stroke-width", getThickness)
      .attr("stroke", getStrokeColour)

      if (duration * factor + base >= maxTime.val) {
        $play.prop('disabled',false);
        $pause.prop('disabled',true);
        $resume.prop('disabled',true);
        console.log("Stopping");
        timer.stop();
      }

      
      


  });

  $play.prop('disabled',true);
      $pause.prop('disabled',false);
}

function resume () {
  timer = d3.timer(function(duration) {
      // console.log(minTime)
      document.getElementById("slider11").value = duration * factor + base
      const $valueSpan = $('.valueSpan');
      const $value = $('#slider11');
      $valueSpan.html("Time: " + $value.val() + " nanos");
      // console.log(duration);
      d3.selectAll("circle")
      .attr("r", function(node) { return getRadius(node) })
      d3.selectAll("line")
      .attr("stroke-width", getThickness)
      .attr("stroke", getStrokeColour)

      if (duration * factor + base >= maxTime.val) {
        $play.prop('disabled',false);
        $pause.prop('disabled',true);
        $resume.prop('disabled',true);
        console.log("Stopping");
        timer.stop();
      }

      
  });

  $pause.prop('disabled',false);
      $resume.prop('disabled',true );
}

function myFunction() {
  timer.stop();
  const $valueSlider = $('#slider11');
  base = Number($valueSlider.val())
  $resume.prop('disabled',false);
  $pause.prop('disabled',true);
}

function updateMaxD () {
  const $maxD = $('#maxD');
  maxD.val = Number($maxD.val());
}

function getNeighbors(node) {
  return links.reduce(function (neighbors, link) {
      if (link.target.id === node.id) {
        neighbors.push(link.source.id)
      } else if (link.source.id === node.id) {
        neighbors.push(link.target.id)
      }
      return neighbors
    },
    [node.id]
  )
}

function isNeighborLink(node, link) {
  return link.target.id === node.id || link.source.id === node.id
}

function getThickness(line) {
  const $value = $('#slider11');
var time = $value.val()

  var throughs = throughputs[line.source.id + "-" + line.target.id]
    // console.log(line.source.id + "-" + line.target.id);
    var limiters = throughputlimitss[line.source.id + "-" + line.target.id]
    console.log(limiters);
    if(limiters == undefined || time < limiters.min || time > limiters.max) {
        return 2
    }
    // var ind = Math.floor((time - limiters.min) * timeArr.length / (limiters.max - limiters.min))

    var l = 0
    var r = throughs.length - 1
    while(l <= r) {
        var mid = Math.floor( (l + (r - l) / 2))
        if(throughs[mid].time_out < time) {
            l = mid + 1
        }
        else {
            r = mid - 1
        }
    }
    ind = l

    ind = ind % throughs.length
    
    // console.log(ind);
    // console.log(datass[0].time_stamp);
    // console.log(node.label + " " + ind + " " + timeArr[ind].queue_depth + " "+timeArr[ind].time_out);

    var value = throughs[ind].throughput

    return 2 + 2 * value

}

function getStrokeColour(line) {
  const $value = $('#slider11');
var time = $value.val()

  var throughs = throughputs[line.source.id + "-" + line.target.id]
    // console.log(line.source.id + "-" + line.target.id);
    var limiters = throughputlimitss[line.source.id + "-" + line.target.id]
    console.log(limiters);
    if(limiters == undefined ) {
        return "rgba(255,255,255,1)"
    }
    if(time < limiters.min || time > limiters.max) {
      return "rgba(255,255,255,1)"
    }
    // var ind = Math.floor((time - limiters.min) * timeArr.length / (limiters.max - limiters.min))

    var l = 0
    var r = throughs.length - 1
    while(l <= r) {
        var mid = Math.floor( (l + (r - l) / 2))
        if(throughs[mid].time_out < time) {
            l = mid + 1
        }
        else {
            r = mid - 1
        }
    }
    ind = l;


    ind = ind % throughs.length
    
    // console.log(ind);
    // console.log(datass[0].time_stamp);
    // console.log(node.label + " " + ind + " " + timeArr[ind].queue_depth + " "+timeArr[ind].time_out);

    var value = throughs[ind].throughput

    var col = Math.floor( (255 / 10) * value)

    
    if(line.source.id == "4" && line.target.id == "10") {
      console.log("Index:" + ind);
      console.log("Color: " + col);
    }
    
    return "rgba(" + Math.min(255,col) + "," + Math.max((255 - col),0) + ",0,1)"

    // if (value > 0.5) {
    //   return "red"
    // }
    // return "white"


}

function getmylinefuncstroke(line) {

const $value = $('#slider11');
var time = $value.val()
if ( time >= times[ line.target.id] && time >= times[line.source.id] ) {
        return 6
    }
// else if( time >= timerArr[line.source.id] - interval * 0.01) {
//     return 'orange'
// }
// else if( time >= timerArr[line.source.id] - interval * 0.02) {
//     return 'orange'
// }
// else if( time >= timerArr[line.source.id] - interval * 0.03) {
//     return 'orange'}
// else if( time >= timerArr[line.source.id] - interval * 0.04) {
//     return 'orange'
// }
// else if( time >= timerArr[line.source.id] - interval * 0.05) {
    // return 'orange'}
return 2

}

function getRadius(node) {
    const $value = $('#slider11');
    var time = $value.val()
    // console.log(datass);
    var timeArr = datass[node.label]
    var limiters = limitss[node.label]
    if(limiters == undefined) {
      // console.log("Undefined is " + node.label);
      return 20
    }
    if(time < limiters.min || time > limiters.max) {
        console.log(node.label + " " + " " + time);
        return 20
    }
    // var ind = Math.floor((time - limiters.min) * timeArr.length / (limiters.max - limiters.min))

    var l = 0
    var r = timeArr.length - 1
    while(l <= r) {
        var mid = Math.floor( (l + (r - l) / 2))
        if(timeArr[mid].time_out < time) {
            l = mid + 1
        }
        else {
            r = mid - 1
        }
    }
    ind = l

    ind = ind % timeArr.length
    
    // console.log(ind);
    // console.log(datass[0].time_stamp);
    console.log(node.label + " " + ind + " " + timeArr[ind].queue_depth + " "+timeArr[ind].time_out);

    var value = timeArr[ind].queue_depth

    return Math.min(maxRad, 20 + ((maxRad - minRad)/(maxD.val)) * value)


}

function getDepth(node) {
    const $value = $('#slider11');
    var time = $value.val()
    // console.log(datass);
    var timeArr = datass[node.label]
    var limiters = limitss[node.label]
    if(limiters == undefined) {
      // console.log("Undefined is " + node.label);
      return 0
    }
    if(time < limiters.min || time > limiters.max) {
        console.log(node.label + " " + " " + time);
        return 0
    }
    // var ind = Math.floor((time - limiters.min) * timeArr.length / (limiters.max - limiters.min))

    var l = 0
    var r = timeArr.length - 1
    while(l <= r) {
        var mid = Math.floor( (l + (r - l) / 2))
        if(timeArr[mid].time_out < time) {
            l = mid + 1
        }
        else {
            r = mid - 1
        }
    }
    ind = l

    ind = ind % timeArr.length
    
    // console.log(ind);
    // console.log(datass[0].time_stamp);
    // console.log(node.label + " " + ind + " " + timeArr[ind].queue_depth + " "+timeArr[ind].time_out);

    var value = timeArr[ind].queue_depth

    return value


}

function getNodeColor(node, neighbors) {
//   if (Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1) {
//     return node.level === 1 ? 'blue' : 'green'
//   }
//   const $value = $('#slider11');
//   var time = $value.val()
//   if ( time >= times[node.label] ) {
//           return 'yellow'
//       }
//   else if( time >= times[node.label] - interval * 0.01) {
//       return 'yellow'
//   }
//   else if( time >= times[node.label] - interval * 0.02) {
//       return 'gray'
//   }
//   else if( time >= times[node.label] - interval * 0.03) {
//       return 'red'
//   }
//   else if( time >= times[node.label] - interval * 0.04) {
//       return 'gray'
//   }
//   else if( time >= times[node.label] - interval * 0.05) {
//       return 'red'
//   }
  return 'yellow'
}


function getLinkColor(node, link) {
  return isNeighborLink(node, link) ? 'green' : '#E5E5E5'
}

function getVal(line) {
  const $value = $('#slider11');
var time = $value.val()

  var throughs = throughputs[line.source.id + "-" + line.target.id]
    // console.log(line.source.id + "-" + line.target.id);
    var limiters = throughputlimitss[line.source.id + "-" + line.target.id]
    console.log(limiters);
    if(limiters == undefined || time < limiters.min || time > limiters.max) {
        return 0
    }
    // var ind = Math.floor((time - limiters.min) * timeArr.length / (limiters.max - limiters.min))

    var l = 0
    var r = throughs.length - 1
    while(l <= r) {
        var mid = Math.floor( (l + (r - l) / 2))
        if(throughs[mid].time_out < time) {
            l = mid + 1
        }
        else {
            r = mid - 1
        }
    }
    ind = l

    ind = ind % throughs.length
    
    // console.log(ind);
    // console.log(datass[0].time_stamp);
    // console.log(node.label + " " + ind + " " + timeArr[ind].queue_depth + " "+timeArr[ind].time_out);

    return throughs[ind].throughput

    

}

function getTextColor(node, neighbors) {
  return Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1 ? 'green' : 'black'
}

var width = 1000
var height = 600

var svg = d3.select('svg')
svg.attr('width', width).attr('height', height)

// simulation setup with all forces
var linkForce = d3
  .forceLink()
  .id(function (link) { return link.id })
  .distance(function () { return 200 })
  .strength(function (link) { return 0 })

var simulation = d3
  .forceSimulation()
  .force('link', linkForce)
  // .force('charge', d3.forceManyBody().strength(-400))
  // .force('center', d3.forceCenter(width / 2, height / 2))
  // .force('collide', d3.forceCollide().strength(1))

var dragDrop = d3.drag().on('start', function (node) {
  node.fx = node.x
  node.fy = node.y
}).on('drag', function (node) {
  simulation.alphaTarget(0.1).restart()
  node.fx = d3.event.x
  node.fy = d3.event.y
}).on('end', function (node) {
  if (!d3.event.active) {
    simulation.alphaTarget(0)
  }
  node.fx = null
  node.fy = null
})

function selectNode(selectedNode) {
  var neighbors = getNeighbors(selectedNode)

  // we modify the styles to highlight selected nodes
  nodeElements.attr('fill', function (node) { return getNodeColor(node, neighbors) })
  textElements.attr('fill', function (node) { return getTextColor(node, neighbors) })
  linkElements.attr('stroke', function (link) { return getLinkColor(selectedNode, link) })
}

var linkElements = svg.append("g")
  .attr("class", "links")
  .selectAll("line")
  .data(links)
  .enter().append("line")
    .attr("stroke-width", 2)
	  .attr("stroke", "rgba(255,255,255, 1.0)")
    // .on("mouseover", function(line) {
    //   document.getElementById("disp").innerHTML = getVal(line) + " Gbps"
    // })
    .on("mouseover", function(line) {		
            div.transition()		
                .duration(20)		
                .style("opacity", .9);		
            div	.html(line.source.id + "->" + line.target.id + " " + getVal(line) + " Gbps")	
                .style("left", (d3.event.pageX + 20) + "px")		
                .style("top", (d3.event.pageY) + "px");	
            })					
        .on("mouseout", function(line) {		
            div.transition()		
                .duration(10)		
                .style("opacity", 0);	
        })
        .on("click", function(line) {
          location.href = "http://localhost:5000/test/" + line.source.id + "/" + line.target.id
        });

var nodeElements = svg.append("g")
  .attr("class", "nodes")
  .selectAll("circle")
  .data(nodes)
  .enter().append("circle")
    .attr("r", 20)
    .attr("cx", 500)
    .attr("cy", 500)
    .attr("fill", getNodeColor)
    .attr("stroke", "black")
    .attr("stroke-width", "1")
    .call(dragDrop)
    .on("click", function(selectedNode) {
        location.href = "http://localhost:5000/switches/" + selectedNode.label
    })
    .on("mouseover", function(node) {		
            div.transition()		
                .duration(20)		
                .style("opacity", .9);		
            div	.html( getDepth(node) + " Packets")	
                .style("left", (d3.event.pageX + 20) + "px")		
                .style("top", (d3.event.pageY) + "px");	
            })					
        .on("mouseout", function(node) {		
            div.transition()		
                .duration(10)		
                .style("opacity", 0);	
        });

var textElements = svg.append("g")
  .attr("class", "texts")
  .selectAll("text")
  .data(nodes)
  .enter().append("text")
    .text(function (node) { return  "S" + node.label })
    .style("fill", "white")
    .on("mouseover", function(node) {
      d3.select(this)
      .attr("font-size", "20")
      .style("fill", "orange")
      .style("text-decoration","underline")
      .text(d3.select(this).html() + " Level " + node.level)
    })
    .on("mouseout", function(node) {
      d3.select(this)
      .attr("font-size", "15")
      .style("fill", "white")
      .style("text-decoration","")
      .text(function (node) { return  "S" + node.label })
    })
	  .attr("font-size", 15)
	  .attr("dx", 20)
    .attr("dy", 4)
    // .on('click', gotoSwitch) //my addition



simulation.nodes(nodes).on('tick', () => {
  nodeElements
    .attr('cx', function (node) { return node.x })
    .attr('cy', function (node) { return node.y })
  textElements
    .attr('x', function (node) { return node.x })
    .attr('y', function (node) { return node.y })
  linkElements
    .attr('x1', function (link) { 
      if( levels[link.source.id] < levels[link.target.id])
        return link.source.x - 8
      else return link.source.x + 8
      })
    .attr('y1', function (link) { return link.source.y })
    .attr('x2', function (link) { 
      if( levels[link.source.id] < levels[link.target.id])
        return link.target.x - 8
      else return link.target.x + 8
     })
    .attr('y2', function (link) { return link.target.y })
})

simulation.force("link").links(links)
</script>
</div>

{% endblock page_content %}
